;; -*- mode: clojure; -*-

(ns torque.reader
  (:require
    [torque.reader.types :as ty] ;; (get-char peek-char)
    [torque.string :as str]))

(def *features* nil)

(def ^:dynamic *resolve-symbol*
  "Qualifies a symbol with its full namespace"
  (fn [symbol]
    (throw
     (ex-info (str "Symbol resolution isn't available in this reader environment,"
                   "thus syntax quote cannot be used.")
              {:symbol symbol}))))

(def macros     (make-array 128))
(def extensions (make-array 128))

(defn macro? [macros ch]
  (and (> ch 0) (< ch 128) (boolean (aget macros ch))))

(defn ^:private throw-not-an-extension [token]
  (throw
    (ex-info (str "Char does not dispatch to a reader extension: "
                  (string (bytes token)))
      {:token token})))

(defn ^:private unbalanced [type]
  (fn [stream]
    (throw
      (ex-info
        (str "Encountered unbalanced parenthesis: "
             type
             ", while reading")
        {:type type}))))

(defn ^:private throw-unknown-escape [ch stream]
  (throw
    (ex-info
      (str "Encountered unknown escape sequence: "
           ch
           ", while reading")
      {:char ch})))

(defn ^:private throw-incomplete-escape [stream]
  (throw (ex-info "Incomplete escape sequence" {})))

(defn ^:private throw-unknown-char [token stream]
  (throw
    (ex-info (str "Encountered unkonwn char sequence: " token)
      {:token token})))

(defn ^:private throw-form-not-meta [form stream]
  (throw
   (ex-info (str "Can't set meta on form that doesn't support meta data")
     {:form form})))

(defn ^:private throw-not-a-meta-form [form stream]
  (throw
    (ex-info (str "Form started with ^ but is not a meta form")
      {:form form})))

(defn ^:private throw-not-a-reader-conditional [form]
  (throw
    (ex-info "Form is not a seq of reader conditional branches"
      {:form form})))

(defn ^:private throw-no-reader-condition-applies [form]
  (throw
    (ex-info "No reader condition applies and no default branch was given"
      {:form     form
       :features *features*})))

(defn ^:private throw-eos [stream]
  (throw
    (ex-info "End of stream reached before finishing form"
      {})))

(declare read-or-skip)

(defn ^:private list-reader [until ctor]
  (fn [stream]
    (loop [out []] ;; should be transient
      (let [x (read-or-skip stream until)]
        (if (= x until)
          (apply ctor out)
          (recur (conj out x)))))))

(defn ^:private wrap-reader [sym]
  (fn [stream]
    (list sym (read-or-skip stream nil))))

(defn ^:private whitespace? [ch]
  (when-not (nil? ch)
    (or (== ch \,)
        (str/whitespace? ch))))

(defn ^:private number-literal? [ch stream]
  (or (str/digit? ch)
      (and (or (== ch \+) (== ch \-))
           (-> stream ty/peek-char str/digit?))))

(defn ^:private end-token? [ch]
  (or (nil? ch)
      (and (macro? macros ch)
           (not= ch \')
           (not= ch \#))
      (whitespace? ch)))

(defn ^:private render [coll]
  (string (apply binary coll)))

(defn ^:private read-token [init stream]
  (loop [ch  init
         out []] ;; TODO: should be transient
    (let [nxt (ty/peek-char stream)]
      (if (end-token? nxt)
        (render (conj out ch))
        (recur (ty/read-char stream) (conj out ch))))))

(defn ^:private read-line [stream]
  (loop []
    (let [ch (ty/read-char stream)]
      ;; (print ch)
      (when (and ch (not (== ch \newline)))
        (recur)))))

(defn ^:private parse-number [s]
  (or
    (str/parse-int s)
    ;; (str/parse-float s)
    ))

(defn ^:private escape-char [init stream]
  (if (== init \\)
    (if-let [ch (ty/read-char stream)]
      (cond
        (== ch \0) \0
        (== ch \t) \t
        (== ch \r) \r
        (== ch \n) \n
        (== ch \\) \\
        (== ch \") \"
        (== ch \a) \a
        (== ch \b) \b
        (== ch \f) \f
        ;; TODO: allow unicode escape sequences
        :else (throw-unknown-escape ch stream))
      (throw-incomplete-escape stream))
    init))

(defn ^:private read-char [stream]
  (if-let [init (ty/read-char stream)]
    (let [token (read-token init stream)]
      (cond
        (= (count token) 1)   (str/at token 0)
        (= token "newline")   \newline
        (= token "space")     \space
        (= token "tab")       \tab
        (= token "backspace") \backspace
        (= token "formfeed")  \formfeed
        (= token "return")    \return
        ;; TODO: read unicode escape sequences
        :else                 (throw-unknown-char token stream)))
    (throw-eos stream)))

(defn ^:private read-string [stream]
  (loop [ch  (ty/read-char stream)
         out []]
    (if-not (nil? ch)
      (if (== ch \")
        (render out)
        (let [escaped (escape-char ch stream)]
          (recur (ty/read-char stream) (conj out escaped))))
      (throw-eos stream))))

(defn ^:private read-keyword [stream]
  (if-let [init (ty/read-char stream)]
    (let [token (read-token init stream)]
      (keyword token))
    (throw-eos stream)))

(defn ^:private read-meta [stream]
  (let [meta (read-or-skip stream nil)
        form (read-or-skip stream nil)]
    (if (has-meta? form)
      (cond
        (keyword? meta) (vary-meta form assoc meta true)
        (map? meta)     (vary-meta form merge meta)
        :else           (throw-not-a-meta-form meta stream))
      (throw-form-not-meta form stream))))

(defn ^:private select-branch [kv]
  (when (or (and *features* (*features* (first kv)))
            (= :default (first kv)))
    (second kv)))

(defn ^:private read-conditional [stream]
  (let [form (read-or-skip stream nil)]
    (if (seq? form)
      (or (some select-branch (partition 2 form))
          (throw-no-reader-condition-applies form))
      (throw-not-a-reader-conditional form))))

(defn ^:private read-unquote [stream]
  (if-let [ch (ty/peek-char stream)]
    (let [sym (if (== ch \@)
                (do (ty/read-char stream)
                    'torque.core/unquote-splicing)
                'torque.core/unquote)]
      (list sym (read-or-skip stream nil)))
    (throw-eos stream)))

(defn ^:private quote? [form]
  (and (list? form)
       (= 'quote (first form))))

(defn ^:private unquote? [form]
  (and (list? form)
       (= 'torque.core/unquote (first form))))

(defn ^:private unquote-splicing? [form]
  (and (list? form)
       (= 'torque.core/unquote-splicing (first form))))

(def ^:dynamic ^:private *auto-gensyms* nil)

(defn expand-auto-gensym [symbol]
  (or (get @*auto-gensyms* symbol)
      (let [auto-sym (gensym (str (name symbol) "_"))]
        (swap! *auto-gensyms* assoc symbol auto-sym)
        auto-sym)))

(declare expand-quoted-seq)

(defn ^:private expand-syntax-quote [form]
  (cond (symbol? form)  (if (str/ends-with? (name form) "#")
                          (list 'quote (expand-auto-gensym form))
                          (list 'quote (*resolve-symbol* form)))
        (quote? form)   (list 'list ''quote (expand-syntax-quote (second form)))
        (unquote? form) (second form)
        (vector? form)  (->> form
                             expand-quoted-seq
                             (list 'torque.core/apply 'torque.core/vector))
        (list? form)    (->> form
                             expand-quoted-seq
                             (list 'torque.core/seq))
        (set? form)     (->> form
                             expand-quoted-seq
                             (list 'torque.core/hash-set))
        (map? form)     (->> form
                             (map (fn [[k v]]
                                    [(expand-syntax-quote k)
                                     (expand-syntax-quote v)]))
                             (into {}))
        :else           form))

(defn ^:private expand-quoted-seq [coll]
  (->> coll
       (map (fn [form]
              (cond
                (unquote-splicing? form) (second form)
                :else                    (vector (expand-syntax-quote form)))))
       vec
       (cons 'torque.core/concat)))

(defn ^:private read-syntax-quote [stream]
  (if-let [form (read-or-skip stream nil)]
    (binding [*auto-gensyms* (atom {})]
      (expand-syntax-quote form))
    (throw-eos stream)))

(defn ^:private read-macro [macros init stream]
  (when-let [macro (aget macros init)]
    (macro stream)))

(defn ^:private read-extension [stream]
  (if-let [init (read-char stream)]
    (if (macro? extensions init)
      (read-macro extensions init stream)
      (throw-not-an-extension init))
    (throw-eos stream)))

(defn ^:private try-number [init stream]
  (when (number-literal? init stream)
    (parse-number (read-token init stream))))

(defn ^:private try-macros [init stream]
  (read-macro macros init stream))

(defn ^:private try-symbol [init stream]
  (let [token (read-token init stream)]
    (cond
      (= token "nil")   nil
      (= token "true")  true
      (= token "false") false
      :else (symbol token))))

(defn ^:private skip-whitespace [stream]
  (loop []
    (when-let [ch (ty/peek-char stream)]
      (when (whitespace? ch)
        (ty/read-char stream)
        (recur))))
  stream)

(defn ^:private skip-comments [stream]
  (loop []
    (when-let [ch (ty/peek-char stream)]
      (when (== ch \;)
        (read-line stream)
        (skip-whitespace stream)
        (recur))))
  stream)

(defn ^:private read-or-skip [stream terminator]
  (skip-whitespace stream)
  (skip-comments stream)
  (if-let [ch (ty/read-char stream)]
    (if (= ch terminator)
      terminator
      (or
       (try-number ch stream)
       (try-macros ch stream)
       (try-symbol ch stream)))
    (if terminator
      (throw-eos stream)
      ::eof)))

(defn read [stream]
  (read-or-skip stream nil))

(defn io-stream [io]
  (ty/io-stream io))

(defmacro with-features [features & forms]
  `(binding [*features* (set (concat *features* ~features))]
     ~@forms))

(aset macros \( (list-reader \) list))
(aset macros \[ (list-reader \] vector))
(aset macros \{ (list-reader \} hash-map))
(aset macros \\ read-char)
(aset macros \" read-string)
(aset macros \: read-keyword)
(aset macros \^ read-meta)
(aset macros \@ (wrap-reader 'torque.core/deref))
(aset macros \' (wrap-reader 'quote))
(aset macros \` read-syntax-quote)
(aset macros \~ read-unquote)
(aset macros \# read-extension)
(aset macros \) (unbalanced ")"))
(aset macros \] (unbalanced "]"))
(aset macros \} (unbalanced "}"))

(aset extensions \? read-conditional)
